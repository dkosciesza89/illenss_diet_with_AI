<conversation_summary> <decisions></decisions>
Use user_id (UUID) in user-related tables; store pseudonymized anonymized_user_id for user-facing data.
Persist generated mappings in ingredient_nutrients with columns: model, prompt_hash, provenance, generated_at and unique constraint on (normalized_name,model,prompt_hash).
Create B-tree index on ingredient_nutrients.normalized_name and GIN index on ingredient_nutrients.nutrients (JSONB).
Do not apply partitioning for MVP; design tables to allow later partitioning.
Enable RLS: owners see only their recipes; service role (background jobs) has full access.
Add units table (code, display_name, conversion_to_base_unit, base_unit_type) and store in ingredients fields quantity NUMERIC(9,3), unit_id FK, normalized_name with CHECK quantity > 0.
Add composite B-tree index (anonymized_user_id, created_at), tsv (tsvector) column with GIN index for full-text on title + raw_text, and cached_nutrition (JSONB) with GIN index for fast reads.
Restrict synchronous AI paths to precomputed/cache-backed simple mappings and substitutions to meet SLO <5s; heavy nutrition estimations are asynchronous jobs.
Perform primary validation in the application; add DB-level CHECKs/triggers for critical invariants (e.g., step length, ingredient fields).
Default to soft-delete (deleted_at) with the option for immediate hard-delete on user request; implement purge workflow for GDPR.
<matched_recommendations>
Persist anonymized_user_id and keep mapping to auth.users.id in a service-only table — enables RLS and service access.
Store AI-generated ingredient→nutrient outputs with provenance and uniqueness (normalized_name,model,prompt_hash) — supports reproducibility and deduplication.
Indexing: B-tree on normalized_name, GIN on JSONB nutrients, GIN tsv for full-text — optimizes lookup and search performance.
Defer partitioning for MVP but include created_at and user keys to enable later range/hash partitioning.
RLS policies: auth.uid() = anonymized_user_id for users; grant service role full access — enforces row-level privacy while allowing background processing.
Units normalization and numeric quantity storage enable consistent aggregation and nutrient calculations in base units.
Cached nutrition per recipe (cached_nutrition) plus background ai_jobs for heavy tasks — ensures fast synchronous responses and reliable async processing.
Validate mainly in application; supplement with DB CHECKs/triggers for safety.
Soft-delete by default and separate purge/hard-delete path for GDPR compliance.
Use advisory locks / unique job constraints to avoid duplicate AI tasks and ensure consistent job processing. </matched_recommendations>
<database_planning_summary> Main requirements:
Support Recipe CRUD storing both raw_text (TEXT) and structured recipe_data (JSONB) with fields title, ingredients[] (name, quantity, unit, normalized_name, unit_id), steps[] (each 10–500 chars).
Authentication via Supabase; user profile includes disease (enum), age, sex, allergies.
Fast synchronous AI operations (<5s) for simple mappings/substitutions using precomputed cache; heavy nutrition estimation handled asynchronously with progress/notifications.
Anonymize user data before sending to external AI.
Key entities & relations:
users (internal mapping table: auth_user_id ↔ user_id UUID ↔ anonymized_user_id UUID).
recipes (owner: anonymized_user_id, raw_text, recipe_data JSONB, tsv, cached_nutrition JSONB, deleted_at).
ingredients (linked to recipes, fields: name, normalized_name, quantity NUMERIC(9,3), unit_id FK).
units (code, display_name, conversion_to_base_unit, base_unit_type).
ingredient_nutrients (normalized_name, nutrients JSONB, model, prompt_hash, provenance, generated_at) with unique constraint and indexes.
ai_jobs / tasks (id, recipe_id, type, status, result JSONB, attempts, started_at, finished_at) for async processing.
recipe_audit or ai_logs storing anonymized_user_id and action metadata for auditing.
Security & RLS:
Enable RLS on recipes, ingredients, cached_nutrition so SELECT/UPDATE/DELETE allowed only when auth.uid() = anonymized_user_id; create service-role policies for background workers to bypass RLS as required.
Keep mapping auth_user_id ↔ anonymized_user_id in a table accessible only to service role; audit access to mapping.
Anonymize data before sending to external AI; persist provenance and model metadata in ingredient_nutrients.
Performance & scalability:
Use GIN indexes on JSONB (nutrients, cached_nutrition) and tsv for full-text; B-tree composite indexes (anonymized_user_id, created_at) for fast per-user listing.
Use pg_trgm where fuzzy ingredient name search is required.
Cache precomputed nutrition and use Redis or in-memory cache for hottest items if needed.
Design tables with created_at, user keys and safe FK constraints to allow later partitioning (range by date or hash by user).
Use unique constraints and advisory locks to avoid duplicate async jobs; background workers should update ai_jobs atomically.
Integrity & operational practices:
Enforce critical invariants via DB CHECKs/triggers (e.g., step length, ingredient presence, quantity > 0) while primary validation is in app layer.
Soft-delete by default; implement purge pipeline and logging for GDPR hard-deletes.
Record model/prompt provenance and TTL/stale_at for cached nutrient mappings; schedule refresh jobs.
Implementation notes:
Keep synchronous endpoints reading cached_nutrition / ingredient_nutrients first; if missing, queue async job and return fallback with indicative status.
Use anonymized_user_id in all user-visible tables and queries; server-side services can join to auth_user_id mapping when needed.
Ensure roles and policies in Supabase are tested for both end-user and service-role flows. </database_planning_summary>
<unresolved_issues>
Choice of food composition dataset and licensing — required before final nutrient schema and provenance rules.
Exact TTL/refresh strategy for ingredient_nutrients (when to regenerate mappings and eviction policy).
Precise RLS implementation details for Supabase claims (exact claim names and service-role handling).
Normalization rules/algorithm for normalized_name (tokenization, stemming, canonicalization) and deduplication thresholds.
Definition of base units and conversion factors for all supported units (complete units table population).
Exact synchronous SLO behavior and fallbacks (how to respond when cache miss exceeds SLO).
Retention/purge schedules and audit logging retention for GDPR compliance.
Error/retry strategy and concurrency limits for background ai_jobs processing. </unresolved_issues> </conversation_summary>